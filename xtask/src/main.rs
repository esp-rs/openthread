use std::path::{Path, PathBuf};
use std::{env, fs};

use anyhow::Result;

use clap::{Parser, Subcommand};

use log::LevelFilter;

use tempdir::TempDir;

use paths::PreGenerationPaths;

#[path = "../../openthread-sys/gen/builder.rs"]
mod builder;
#[path = "../../openthread-sys/gen/pregen_paths.rs"]
mod paths;

// Arguments
#[derive(Parser, Debug)]
#[command(author, version, about = "Compile and generate bindings for OpenThread to be used in Rust.", long_about = None, subcommand_required = true)]
struct Args {
    #[command(subcommand)]
    command: Option<Commands>,
}

#[derive(Subcommand, Debug)]
enum Commands {
    /// Generate Rust bindings for openthread and generate .a libraries
    Gen {
        /// If the target is a riscv32 target, force the use of the Espressif RISCV GCC toolchain
        /// (`riscv32-esp-elf-gcc`) rather than the derived `riscv32-unknown-elf-gcc` toolchain which is the "official" RISC-V one
        /// (https://github.com/riscv-collab/riscv-gnu-toolchain)
        #[arg(short = 'e', long)]
        force_esp_riscv_toolchain: bool,

        /// Target triple for which to generate bindings and `.a` libraries
        target: String,
    },
}

fn main() -> Result<()> {
    env_logger::Builder::new()
        .filter_module("xtask", LevelFilter::Info)
        .init();

    // The directory containing the cargo manifest for the 'xtask' package is a
    // subdirectory
    let workspace = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    let workspace = workspace.parent().unwrap().canonicalize()?;

    let sys_crate_root_path = workspace.join("openthread-sys");

    let args = Args::parse();

    if let Some(Commands::Gen {
        target,
        force_esp_riscv_toolchain,
    }) = args.command
    {
        let openthread_config = builder::OpenThreadConfig::default();
        let paths = PreGenerationPaths::derive(&sys_crate_root_path, &target, &openthread_config);

        let builder = builder::OpenThreadBuilder::new(
            sys_crate_root_path.clone(),
            Some(target.clone()),
            // Fake host, but we do need to pass something to CMake
            Some("x86_64-unknown-linux-gnu".into()),
            None,
            None,
            None,
            force_esp_riscv_toolchain,
            openthread_config.clone(),
        );

        let out = TempDir::new("openthread-sys-libs")?;
        builder.compile(out.path(), Some(&paths.libs_dir))?;

        let out = TempDir::new("openthread-sys-bindings")?;
        builder.generate_bindings(out.path(), Some(&paths.bindings_rs_file))?;

        write_config_summary(&paths.config_summary_file, &openthread_config)?;
    }

    Ok(())
}

fn write_config_summary(path: &Path, openthread_config: &builder::OpenThreadConfig) -> Result<()> {
    log::info!("Writing out OpenThread build config to {path:?}");

    let header = "This file is autogenerated and describes the config with which these bindings and libraries were pre-generated.";
    fs::write(path, format!("{header}\n\n{openthread_config}"))?;

    Ok(())
}
